[
  {
    "objectID": "hw8_code.html",
    "href": "hw8_code.html",
    "title": "Basic Modeling",
    "section": "",
    "text": "library(tidyverse)\nlibrary(lubridate)\nlibrary(tidymodels)"
  },
  {
    "objectID": "hw8_code.html#reading-in-data",
    "href": "hw8_code.html#reading-in-data",
    "title": "Basic Modeling",
    "section": "Reading in Data",
    "text": "Reading in Data\nHere I am using encoding = “EUC-KR” to deal with the file that includes non-ASCII characters such as “Temperature(캜)”.\n\nbike_data &lt;- readr::read_csv(\"SeoulBikeData.csv\", locale = readr::locale(encoding = \"EUC-KR\"))\n\nRows: 8760 Columns: 14\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (4): Date, Seasons, Holiday, Functioning Day\ndbl (10): Rented Bike Count, Hour, Temperature(캜), Humidity(%), Wind speed (...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nRenaming variables so they are easy to use, changing certain variables to factors, and adjusting the date format so that all column types are as they should be.\n\nbike_data &lt;- bike_data |&gt;\n  rename(\"date\" = \"Date\",\n         \"rent_bike\" = \"Rented Bike Count\",\n         \"hour\" = \"Hour\",\n         \"temp\" = \"Temperature(캜)\",\n         \"humid\" = \"Humidity(%)\",\n         \"wind\" = \"Wind speed (m/s)\",\n         \"vis\" = \"Visibility (10m)\",\n         \"dew_point\" = \"Dew point temperature(캜)\",\n         \"solar_rad\" = \"Solar Radiation (MJ/m2)\",\n         \"rain\" = \"Rainfall(mm)\",\n         \"snow\" = \"Snowfall (cm)\",\n         \"season\" = \"Seasons\",\n         \"holiday\" = \"Holiday\",\n         \"fun_day\" = \"Functioning Day\") |&gt;\n  mutate(across(c(season, holiday, fun_day), as.factor), date = dmy(date))\nbike_data\n\n# A tibble: 8,760 × 14\n   date       rent_bike  hour  temp humid  wind   vis dew_point solar_rad  rain\n   &lt;date&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n 1 2017-12-01       254     0  -5.2    37   2.2  2000     -17.6      0        0\n 2 2017-12-01       204     1  -5.5    38   0.8  2000     -17.6      0        0\n 3 2017-12-01       173     2  -6      39   1    2000     -17.7      0        0\n 4 2017-12-01       107     3  -6.2    40   0.9  2000     -17.6      0        0\n 5 2017-12-01        78     4  -6      36   2.3  2000     -18.6      0        0\n 6 2017-12-01       100     5  -6.4    37   1.5  2000     -18.7      0        0\n 7 2017-12-01       181     6  -6.6    35   1.3  2000     -19.5      0        0\n 8 2017-12-01       460     7  -7.4    38   0.9  2000     -19.3      0        0\n 9 2017-12-01       930     8  -7.6    37   1.1  2000     -19.8      0.01     0\n10 2017-12-01       490     9  -6.5    27   0.5  1928     -22.4      0.23     0\n# ℹ 8,750 more rows\n# ℹ 4 more variables: snow &lt;dbl&gt;, season &lt;fct&gt;, holiday &lt;fct&gt;, fun_day &lt;fct&gt;"
  },
  {
    "objectID": "hw8_code.html#eda",
    "href": "hw8_code.html#eda",
    "title": "Basic Modeling",
    "section": "EDA",
    "text": "EDA\nChecking for missing values, there does not appear to be any.\n\nsum_na &lt;- function(column){\n sum(is.na(column))\n}\nna_counts &lt;- bike_data |&gt;\n summarize(across(everything(), sum_na))\n\nna_counts\n\n# A tibble: 1 × 14\n   date rent_bike  hour  temp humid  wind   vis dew_point solar_rad  rain  snow\n  &lt;int&gt;     &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1     0         0     0     0     0     0     0         0         0     0     0\n# ℹ 3 more variables: season &lt;int&gt;, holiday &lt;int&gt;, fun_day &lt;int&gt;\n\n\nBasic summary stats for numeric variables and unique values and counts for character variables. It appears that bike rental counts have a standard deviation that’s almost the same values as the mean.\n\nbike_summary &lt;- bike_data |&gt;\n  summarize(across(where(is.numeric),list(mean = mean,\n                                          median = median,\n                                          min = min,\n                                          max = max,\n                                          sd = sd)),\n            across(where(is.factor), ~ length(unique(.)),.names = \"unique_{.col}\")\n  )\nbike_summary\n\n# A tibble: 1 × 53\n  rent_bike_mean rent_bike_median rent_bike_min rent_bike_max rent_bike_sd\n           &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n1           705.             504.             0          3556         645.\n# ℹ 48 more variables: hour_mean &lt;dbl&gt;, hour_median &lt;dbl&gt;, hour_min &lt;dbl&gt;,\n#   hour_max &lt;dbl&gt;, hour_sd &lt;dbl&gt;, temp_mean &lt;dbl&gt;, temp_median &lt;dbl&gt;,\n#   temp_min &lt;dbl&gt;, temp_max &lt;dbl&gt;, temp_sd &lt;dbl&gt;, humid_mean &lt;dbl&gt;,\n#   humid_median &lt;dbl&gt;, humid_min &lt;dbl&gt;, humid_max &lt;dbl&gt;, humid_sd &lt;dbl&gt;,\n#   wind_mean &lt;dbl&gt;, wind_median &lt;dbl&gt;, wind_min &lt;dbl&gt;, wind_max &lt;dbl&gt;,\n#   wind_sd &lt;dbl&gt;, vis_mean &lt;dbl&gt;, vis_median &lt;dbl&gt;, vis_min &lt;dbl&gt;,\n#   vis_max &lt;dbl&gt;, vis_sd &lt;dbl&gt;, dew_point_mean &lt;dbl&gt;, …\n\n\nExploring contingency tables for categorical variables. Going to remove the rows that fall under a “no functional hours” day.\n\nseason_count &lt;- table(bike_data$season)\nseason_count\n\n\nAutumn Spring Summer Winter \n  2184   2208   2208   2160 \n\nholiday_count &lt;- table(bike_data$holiday)\nholiday_count\n\n\n   Holiday No Holiday \n       432       8328 \n\nfun_count &lt;- table(bike_data$fun_day)\nfun_count\n\n\n  No  Yes \n 295 8465 \n\n\nCreating the final dataset by grouping by selected variables, and using the sum or mean of other variables.\n\nbike_data &lt;- bike_data |&gt;\n  filter(fun_day != \"no\") |&gt;\n  group_by(date, season, holiday) |&gt;\n  summarize(total_rent_bike = sum(rent_bike),\n            total_rain = sum(rain),\n            total_snow = sum(snow),\n            mean_temp = mean(temp),\n            mean_humid = mean(humid),\n            mean_wind = mean(wind),\n            mean_vis = mean(vis),\n            mean_dew_point = mean(dew_point),\n            mean_solar_rad = mean(solar_rad))\n\n`summarise()` has grouped output by 'date', 'season'. You can override using\nthe `.groups` argument.\n\nbike_data\n\n# A tibble: 365 × 12\n# Groups:   date, season [365]\n   date       season holiday    total_rent_bike total_rain total_snow mean_temp\n   &lt;date&gt;     &lt;fct&gt;  &lt;fct&gt;                &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;\n 1 2017-12-01 Winter No Holiday            9539        0          0     -2.45  \n 2 2017-12-02 Winter No Holiday            8523        0          0      1.32  \n 3 2017-12-03 Winter No Holiday            7222        4          0      4.88  \n 4 2017-12-04 Winter No Holiday            8729        0.1        0     -0.304 \n 5 2017-12-05 Winter No Holiday            8307        0          0     -4.46  \n 6 2017-12-06 Winter No Holiday            6669        1.3        8.6    0.0458\n 7 2017-12-07 Winter No Holiday            8549        0         10.4    1.09  \n 8 2017-12-08 Winter No Holiday            8032        0          0     -3.82  \n 9 2017-12-09 Winter No Holiday            7233        0          0     -0.846 \n10 2017-12-10 Winter No Holiday            3453        4.1       32.5    1.19  \n# ℹ 355 more rows\n# ℹ 5 more variables: mean_humid &lt;dbl&gt;, mean_wind &lt;dbl&gt;, mean_vis &lt;dbl&gt;,\n#   mean_dew_point &lt;dbl&gt;, mean_solar_rad &lt;dbl&gt;\n\n\nRecreating summary stats on final dataset.\n\nfinal_summary &lt;- bike_data |&gt;\n  summarize(across(where(is.numeric),list(mean = mean,\n                                          median = median,\n                                          min = min,\n                                          max = max,\n                                          sd = sd)),\n            across(where(is.factor), ~ length(unique(.)),.names = \"unique_{.col}\")\n  )\n\n`summarise()` has grouped output by 'date'. You can override using the\n`.groups` argument.\n\nfinal_summary\n\n# A tibble: 365 × 48\n# Groups:   date [365]\n   date       season total_rent_bike_mean total_rent_bike_median\n   &lt;date&gt;     &lt;fct&gt;                 &lt;dbl&gt;                  &lt;dbl&gt;\n 1 2017-12-01 Winter                 9539                   9539\n 2 2017-12-02 Winter                 8523                   8523\n 3 2017-12-03 Winter                 7222                   7222\n 4 2017-12-04 Winter                 8729                   8729\n 5 2017-12-05 Winter                 8307                   8307\n 6 2017-12-06 Winter                 6669                   6669\n 7 2017-12-07 Winter                 8549                   8549\n 8 2017-12-08 Winter                 8032                   8032\n 9 2017-12-09 Winter                 7233                   7233\n10 2017-12-10 Winter                 3453                   3453\n# ℹ 355 more rows\n# ℹ 44 more variables: total_rent_bike_min &lt;dbl&gt;, total_rent_bike_max &lt;dbl&gt;,\n#   total_rent_bike_sd &lt;dbl&gt;, total_rain_mean &lt;dbl&gt;, total_rain_median &lt;dbl&gt;,\n#   total_rain_min &lt;dbl&gt;, total_rain_max &lt;dbl&gt;, total_rain_sd &lt;dbl&gt;,\n#   total_snow_mean &lt;dbl&gt;, total_snow_median &lt;dbl&gt;, total_snow_min &lt;dbl&gt;,\n#   total_snow_max &lt;dbl&gt;, total_snow_sd &lt;dbl&gt;, mean_temp_mean &lt;dbl&gt;,\n#   mean_temp_median &lt;dbl&gt;, mean_temp_min &lt;dbl&gt;, mean_temp_max &lt;dbl&gt;, …\n\n\nExploring plots to see relationships. It makes sense that we see the most bikes being rented in summer months.\n\nggplot(data = bike_data, aes(x = season, fill = holiday)) +\n  geom_bar(position = \"dodge\") +\n  labs(x = \"Season\", title = \"Season and Holiday\") + \n  scale_fill_discrete(\"Holiday\")\n\n\n\n\n\n\n\nggplot(data = bike_data, aes(x = total_rent_bike)) +\n  geom_histogram(binwidth = 500, alpha = 0.7) +\n  labs(x = \"Total Bikes Rented\", title = \"Total Bikes Rented\") \n\n\n\n\n\n\n\nggplot(data = bike_data, aes(x = total_rent_bike, y = mean_temp, color = season)) +\n  geom_point() +\n  labs(x = \"Total Bikes Rented\", y = \"Mean Temperature\", title = \"Bikes Rented and Temperature by Season\") +\n  scale_color_discrete(\"Season\")\n\n\n\n\n\n\n\nggplot(data = bike_data, aes(x = total_rent_bike, y = mean_vis, color = season)) +\n  geom_point() +\n  labs(x = \"Total Bikes Rented\", y = \"Mean Visibility\", title = \"Bikes Rented and Visibility by Season\") +\n  scale_color_discrete(\"Season\")\n\n\n\n\n\n\n\n\nFinding correlation between numeric variables.Beyone dew point and temperature (which is expected to have a high correlation) none of the variables have a particularly strong positive or negative correlation.\n\nnum_data &lt;- bike_data |&gt; \n  ungroup() |&gt;\n  select(where(is.numeric))\n\ncor_mat &lt;- cor(num_data, use = \"complete.obs\")\ncor_mat\n\n                total_rent_bike  total_rain  total_snow   mean_temp  mean_humid\ntotal_rent_bike      1.00000000 -0.21425244 -0.24083601  0.69982423  0.02815752\ntotal_rain          -0.21425244  1.00000000 -0.02249252  0.13981161  0.52824072\ntotal_snow          -0.24083601 -0.02249252  1.00000000 -0.26795142  0.06424711\nmean_temp            0.69982423  0.13981161 -0.26795142  1.00000000  0.40146073\nmean_humid           0.02815752  0.52824072  0.06424711  0.40146073  1.00000000\nmean_wind           -0.17485945 -0.08107366  0.02079190 -0.25895565 -0.22416837\nmean_vis             0.14537586 -0.21828398 -0.10129611  0.01057752 -0.55648011\nmean_dew_point       0.60264807  0.26064386 -0.21082326  0.96261370  0.63026510\nmean_solar_rad       0.68406924 -0.32323141 -0.23149054  0.54348190 -0.27353406\n                  mean_wind    mean_vis mean_dew_point mean_solar_rad\ntotal_rent_bike -0.17485945  0.14537586      0.6026481      0.6840692\ntotal_rain      -0.08107366 -0.21828398      0.2606439     -0.3232314\ntotal_snow       0.02079190 -0.10129611     -0.2108233     -0.2314905\nmean_temp       -0.25895565  0.01057752      0.9626137      0.5434819\nmean_humid      -0.22416837 -0.55648011      0.6302651     -0.2735341\nmean_wind        1.00000000  0.19038959     -0.2841044      0.1076893\nmean_vis         0.19038959  1.00000000     -0.1458334      0.2646339\nmean_dew_point  -0.28410440 -0.14583339      1.0000000      0.3774974\nmean_solar_rad   0.10768927  0.26463391      0.3774974      1.0000000"
  },
  {
    "objectID": "hw8_code.html#splitting-the-data",
    "href": "hw8_code.html#splitting-the-data",
    "title": "Basic Modeling",
    "section": "Splitting the Data",
    "text": "Splitting the Data\nUsing functions from tidymodels to split the data and add in the stratification. Then applying 10-fold cross validation to the training set.\n\nbike_split &lt;- initial_split(bike_data, prop = 0.75, strata = season)\nbike_train &lt;- training(bike_split)\nbike_test &lt;- testing(bike_split)\nbike_10_fold &lt;- vfold_cv(bike_train, 10)"
  },
  {
    "objectID": "hw8_code.html#fitting-mlr-models",
    "href": "hw8_code.html#fitting-mlr-models",
    "title": "Basic Modeling",
    "section": "Fitting MLR Models",
    "text": "Fitting MLR Models\nCreating the first recipe.\n\nbike_recipe1 &lt;-recipe(total_rent_bike ~ ., data = bike_data) |&gt;\n  update_role(date, new_role = \"ID\") |&gt;\n  step_mutate(day_type = factor(if_else(date %&gt;% lubridate::wday(label = TRUE) %in% c(\"Sun\", \"Sat\"), \"weekend\", \"weekday\"))) |&gt;\n  step_normalize(total_rain,\n                 total_snow,\n                 mean_temp,\n                 mean_humid,\n                 mean_wind,\n                 mean_vis,\n                 mean_dew_point, \n                 mean_solar_rad) |&gt;\n  step_dummy(season, holiday, day_type)\n\nbike_recipe1\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:    1\npredictor: 10\nID:         1\n\n\n\n\n\n── Operations \n\n\n• Variable mutation for: factor(if_else(date %&gt;% lubridate::wday(label = TRUE)\n  %in% c(\"Sun\", \"Sat\"), \"weekend\", \"weekday\"))\n\n\n• Centering and scaling for: total_rain, total_snow, mean_temp, ...\n\n\n• Dummy variables from: season, holiday, day_type\n\n\nCreating the second recipe, adding in interactions.\n\nbike_recipe2 &lt;- recipe(total_rent_bike ~ ., data = bike_data) |&gt;\n  update_role(date, new_role = \"ID\") |&gt;\n  step_mutate(day_type = factor(if_else(date %&gt;% lubridate::wday(label = TRUE) %in% c(\"Sun\", \"Sat\"), \"weekend\", \"weekday\"))) |&gt;\n  step_normalize(total_rain,\n                 total_snow,\n                 mean_temp,\n                 mean_humid,\n                 mean_wind,\n                 mean_vis,\n                 mean_dew_point, \n                 mean_solar_rad) |&gt;\n  step_dummy(season, holiday, day_type) |&gt;\n  step_interact(terms = ~ starts_with(\"season\")*starts_with(\"holiday\")) |&gt;\n  step_interact(terms = ~ starts_with(\"season\")*mean_temp) |&gt;\n  step_interact(terms = ~ mean_temp*total_rain)\n\nbike_recipe2\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:    1\npredictor: 10\nID:         1\n\n\n\n\n\n── Operations \n\n\n• Variable mutation for: factor(if_else(date %&gt;% lubridate::wday(label = TRUE)\n  %in% c(\"Sun\", \"Sat\"), \"weekend\", \"weekday\"))\n\n\n• Centering and scaling for: total_rain, total_snow, mean_temp, ...\n\n\n• Dummy variables from: season, holiday, day_type\n\n\n• Interactions with: starts_with(\"season\") * starts_with(\"holiday\")\n\n\n• Interactions with: starts_with(\"season\") * mean_temp\n\n\n• Interactions with: mean_temp * total_rain\n\n\nCreating the third recipe, adding in the quadratic terms.\n\nbike_recipe3 &lt;- recipe(total_rent_bike ~ ., data = bike_data) |&gt;\n  update_role(date, new_role = \"ID\") |&gt;\n  step_mutate(day_type = factor(if_else(date %&gt;% lubridate::wday(label = TRUE) %in% c(\"Sun\", \"Sat\"), \"weekend\", \"weekday\"))) |&gt;\n  step_normalize(total_rain,\n                 total_snow,\n                 mean_temp,\n                 mean_humid,\n                 mean_wind,\n                 mean_vis,\n                 mean_dew_point, \n                 mean_solar_rad) |&gt;\n  step_dummy(season, holiday, day_type) |&gt;\n  step_interact(terms = ~ starts_with(\"season\")*starts_with(\"holiday\")) |&gt;\n  step_interact(terms = ~ starts_with(\"season\")*mean_temp) |&gt;\n  step_interact(terms = ~ mean_temp*total_rain) |&gt;\n  step_poly(total_rain,\n            total_snow,\n            mean_temp,\n            mean_humid,\n            mean_wind,\n            mean_vis,\n            mean_dew_point, \n            mean_solar_rad,\n            degree = 2)\n\nbike_recipe3\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:    1\npredictor: 10\nID:         1\n\n\n\n\n\n── Operations \n\n\n• Variable mutation for: factor(if_else(date %&gt;% lubridate::wday(label = TRUE)\n  %in% c(\"Sun\", \"Sat\"), \"weekend\", \"weekday\"))\n\n\n• Centering and scaling for: total_rain, total_snow, mean_temp, ...\n\n\n• Dummy variables from: season, holiday, day_type\n\n\n• Interactions with: starts_with(\"season\") * starts_with(\"holiday\")\n\n\n• Interactions with: starts_with(\"season\") * mean_temp\n\n\n• Interactions with: mean_temp * total_rain\n\n\n• Orthogonal polynomials on: total_rain, total_snow, mean_temp, ...\n\n\nSetting up the linear model fit and fitting the models to determine best performance. It appears that model 3 has a smaller RMSE and high R-squared value so that would be the best fit.\n\nbike_mod &lt;- linear_reg() |&gt;\n  set_engine(\"lm\")\n\nbike_wfl &lt;- workflow() |&gt;\n  add_recipe(bike_recipe1) |&gt;\n  add_model(bike_mod) |&gt;\n  fit_resamples(bike_10_fold)\n\nbike_wfl2 &lt;- workflow() |&gt;\n  add_recipe(bike_recipe2) |&gt;\n  add_model(bike_mod)|&gt;\n  fit_resamples(bike_10_fold)\n\n→ A | warning: prediction from a rank-deficient fit may be misleading\n\n\nThere were issues with some computations   A: x1\n\n\nThere were issues with some computations   A: x8\n\n\nThere were issues with some computations   A: x10\n\n\n\n\nbike_wfl3 &lt;- workflow() |&gt;\n  add_recipe(bike_recipe3) |&gt;\n  add_model(bike_mod)|&gt;\n  fit_resamples(bike_10_fold)\n\n→ A | warning: prediction from a rank-deficient fit may be misleading\n\nrbind(bike_wfl |&gt; collect_metrics() |&gt; mutate(workflow = \"bike_wfl1\"),\n      bike_wfl2 |&gt; collect_metrics() |&gt; mutate(workflow = \"bike_wfl2\"),\n      bike_wfl3 |&gt; collect_metrics() |&gt; mutate(workflow = \"bike_wfl3\"))\n\n# A tibble: 6 × 7\n  .metric .estimator     mean     n   std_err .config              workflow \n  &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;                &lt;chr&gt;    \n1 rmse    standard   5371.       10  373.     Preprocessor1_Model1 bike_wfl1\n2 rsq     standard      0.710    10    0.0509 Preprocessor1_Model1 bike_wfl1\n3 rmse    standard   6307.       10 1646.     Preprocessor1_Model1 bike_wfl2\n4 rsq     standard      0.723    10    0.0663 Preprocessor1_Model1 bike_wfl2\n5 rmse    standard   6035.       10 1404.     Preprocessor1_Model1 bike_wfl3\n6 rsq     standard      0.725    10    0.0662 Preprocessor1_Model1 bike_wfl3\n\n\nUsing the chosen model on the full training and test data.\n\nbike_wfl3 &lt;- workflow() |&gt;\n  add_recipe(bike_recipe3) |&gt;\n  add_model(bike_mod)\n\nfinal_fit &lt;- last_fit(bike_wfl3, bike_split)\n\n→ A | warning: prediction from a rank-deficient fit may be misleading\n\nfinal_metrics &lt;- final_fit |&gt; collect_metrics()\nfinal_metrics\n\n# A tibble: 2 × 4\n  .metric .estimator .estimate .config             \n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;               \n1 rmse    standard    6259.    Preprocessor1_Model1\n2 rsq     standard       0.618 Preprocessor1_Model1\n\nfinal_model &lt;- final_fit |&gt;\n  extract_fit_parsnip()\nmodel_coef &lt;- tidy(final_model)\nmodel_coef\n\n# A tibble: 32 × 5\n   term                               estimate std.error statistic      p.value\n   &lt;chr&gt;                                 &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n 1 (Intercept)                          18008.     3073.     5.86  0.0000000151\n 2 season_Spring                        -2606.     4123.    -0.632 0.528       \n 3 season_Summer                        14849.     6589.     2.25  0.0251      \n 4 season_Winter                         2278.    15600.     0.146 0.884       \n 5 holiday_No.Holiday                    2626.     2872.     0.915 0.361       \n 6 day_type_weekend                     -1734.      681.    -2.55  0.0115      \n 7 season_Spring_x_holiday_No.Holiday    -508.     4206.    -0.121 0.904       \n 8 season_Summer_x_holiday_No.Holiday    2231.     5667.     0.394 0.694       \n 9 season_Winter_x_holiday_No.Holiday   -9305.    15572.    -0.598 0.551       \n10 season_Spring_x_mean_temp             8181.     4092.     2.00  0.0467      \n# ℹ 22 more rows"
  }
]